#!/usr/bin/env ruby
#
# Serves all examples, mounted into Webrick.
#
$:.unshift File.expand_path(File.dirname(__FILE__) + "/../lib")
require 'stringio'
require 'webrick/httpserver'
require 'camping'

# All applications share a single database
Camping::Models::Base.establish_connection :adapter => 'sqlite3', :database => 'serve.db'
Camping::Models::Base.logger = Logger.new('camping.log')

apps = 
    Dir['*'].select do |d|
        if File.directory? "#{d}"
            begin
                load "#{d}/#{d}.rb"
                true
            rescue Exception => e
                puts "Camping app `#{d}' will not load: #{e.class} #{e.message}"
            end
        end
    end
apps.map! do |app|
    begin
        klass = Object.const_get(Object.constants.grep(/^#{app}$/i)[0])
        klass.create if klass.respond_to? :create
        [app, klass]
    rescue Exception => e
        puts "Camping app `#{app}' will not load: #{e.class} #{e.message}"
    end
end
apps.compact!

s = WEBrick::HTTPServer.new(:BindAddress => '0.0.0.0', :Port => 3301)
apps.each do |app, klass|
    s.mount_proc("/#{app}") do |req, resp|
        Object.instance_eval do
            remove_const :ENV
            const_set :ENV, req.meta_vars
        end
        def resp.<<(data)
            raw_header, body = "#{data}".split(/^[\xd\xa]+/on, 2) 

            begin
              header = WEBrick::HTTPUtils::parse_header(raw_header)
              if /^(\d+)/ =~ header['status'][0]
                self.status = $1.to_i
                header.delete('status')
              end
              header.each{|key, val| self[key] = val.join(", ") }
            rescue => ex
              raise WEBrick::HTTPStatus::InternalServerError, ex.message
            end
            self.body = body
        end
        klass.run((req.body and StringIO.new(req.body)), resp)
        nil
    end
end
trap(:INT) do
    s.shutdown
end
s.start
