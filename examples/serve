#!/usr/bin/env ruby
#
# Serves all examples, mounted into Webrick.
#
$:.unshift File.expand_path(File.dirname(__FILE__) + "/../lib")
require 'stringio'
require 'webrick/httpserver'
require 'camping'

# All applications share a single database
Camping::Models::Base.establish_connection :adapter => 'sqlite3', :database => 'serve.db'
Camping::Models::Base.logger = Logger.new('camping.log')

# Find the working applications
apps = 
    Dir['*'].select do |d|
        if File.directory? "#{d}"
            begin
                load "#{d}/#{d}.rb"
                true
            rescue Exception => e
                puts "Camping app `#{d}' will not load: #{e.class} #{e.message}"
            end
        end
    end
apps.map! do |app|
    begin
        klass = Object.const_get(Object.constants.grep(/^#{app}$/i)[0])
        klass.create if klass.respond_to? :create
        [app, klass]
    rescue Exception => e
        puts "Camping app `#{app}' will not load: #{e.class} #{e.message}"
    end
end
apps.compact!

s = WEBrick::HTTPServer.new(:BindAddress => '0.0.0.0', :Port => 3301)

# Root mount displays applications mounted
s.mount_proc("/") do |req, resp|
    welcome = "Welcome to the Camping Example Server"
    b = Markaby::Builder.new({}, {})
    b = b.instance_eval do
        html do
            head { title welcome }
            body do
                h1 welcome
                p %{
                    Good day.  These are the Camping sample applications.  The code
                    for each of these applications is available in its own folder
                    under examples.  A link to the application's source code is 
                    also given next to each one.
                }
                p %{Well, click on the application's name to give a try.}
                ul do
                    apps.each do |app, klass|
                        li do
                            h3(:style => "display: inline") { a app, :href => "/#{app}" }
                            small { text " / " ; a "View Source", :href => "/code/#{app}" }
                        end
                    end
                end
            end
        end
    end
    resp.body = b.to_s
end

# Mount which handles each application
apps.each do |app, klass|
    # Mount for view source
    s.mount_proc("/code/#{app}") do |req, resp|
        resp.header['Content-Type'] = 'text/plain'
        resp.body = File.read("#{app}/#{app}.rb")
    end

    s.mount_proc("/#{app}") do |req, resp|
        Object.instance_eval do
            remove_const :ENV
            const_set :ENV, req.meta_vars
        end
        def resp.<<(data)
            raw_header, body = "#{data}".split(/^[\xd\xa]+/on, 2) 

            begin
              header = WEBrick::HTTPUtils::parse_header(raw_header)
              if /^(\d+)/ =~ header['status'][0]
                self.status = $1.to_i
                header.delete('status')
              end
              header.each{|key, val| self[key] = val.join(", ") }
            rescue => ex
              raise WEBrick::HTTPStatus::InternalServerError, ex.message
            end
            self.body = body
        end
        klass.run((req.body and StringIO.new(req.body)), resp)
        nil
    end
end

# Server up
trap(:INT) do
    s.shutdown
end
s.start
