#!/usr/bin/env ruby

# this line prevents other db adapters from being loaded (oci8 was
# causing some pain.)
RAILS_CONNECTION_ADAPTERS = %w[sqlite]

require 'stringio'
require 'webrick/httpserver'
require 'camping/webrick'

(puts <<USAGE; exit) if ARGV.length == 0
#{File.basename($0)}, the microframework ON-button for ruby #{RUBY_VERSION} (#{RUBY_RELEASE_DATE}) [#{RUBY_PLATFORM}]
Usage: #{File.basename($0)} your.camping.rb [your.camping.db]
USAGE

script, db = ARGV[0..-1]

unless db
    homes = []
    homes << File.join( ENV['HOME'], '.camping.db' ) if ENV['HOME']
    homes << File.join( ENV['APPDATA'], 'Camping.db' ) if ENV['APPDATA']
    homes.each do |db|
        break if File.exists?( db )
    end
end

Camping::Models::Base.establish_connection :adapter => 'sqlite3', :database => db

class WEBrick::CampingHandler
    attr_accessor :klass, :mtime
end

# Load the script, locate the module
def camp_load(server, script, klass = nil)
    Object.instance_eval { remove_const klass.name } if klass
    mtime = File.mtime(script)
    load script
    klass = Object.const_get(Object.constants.grep(/^#{File.basename(script)[/^(\w+)/,1]}$/i)[0]) rescue nil
    klass ||= Camping
    klass.create if klass.respond_to? :create

    brick = WEBrick::CampingHandler.new(server, klass)
    brick.mtime = mtime
    brick
end

# Mount the root
s = WEBrick::HTTPServer.new(:BindAddress => '0.0.0.0', :Port => 3301)
brick = camp_load( s, script )
s.mount_proc("/") do |req, resp|
    newtime = File.mtime( script )
    if newtime > brick.mtime
        brick = camp_load( s, script, brick.klass )
    end
    brick.do_GET(req, resp)
    nil
end

# Server up
trap(:INT) do
    s.shutdown
end
s.start
