#!/usr/bin/env ruby

# this line prevents other db adapters from being loaded (oci8 was
# causing some pain.)
unless Object.const_defined? :RAILS_CONNECTION_ADAPTERS
    RAILS_CONNECTION_ADAPTERS = []
end
RAILS_CONNECTION_ADAPTERS.replace %w[sqlite]

require 'delegate'
require 'optparse'
require 'ostruct'
require 'stringio'
require 'rubygems'
require 'camping'
require 'camping/session'
require 'camping/reloader'
require 'yaml'

conf = OpenStruct.new(:host => '0.0.0.0', :port => 3301)

homes = []
homes << File.join( ENV['HOME'], '.camping.db' ) if ENV['HOME']
homes << File.join( ENV['APPDATA'], 'Camping.db' ) if ENV['APPDATA']
homes.each do |conf.db|
    break if File.exists?( conf.db )
    rc = File.expand_path( '../.campingrc', conf.db )
    if File.exists? rc
        YAML.load_file(rc).each do |k,v|
           v = v.to_sym if k == 'server'
           conf.send("#{k}=", v)
        end 
    end
end

unless conf.db
    puts "!! No home directory found.  Please specify a database file, see --help."; exit
end

opts = OptionParser.new do |opts|
    opts.banner = "Usage: camping app1.rb, app2.rb..."
    opts.define_head "#{File.basename($0)}, the microframework ON-button for ruby #{RUBY_VERSION} (#{RUBY_RELEASE_DATE}) [#{RUBY_PLATFORM}]"
    opts.separator ""
    opts.separator "Specific options:"

    opts.on("-h", "--host HOSTNAME", "Host for web server to bind to (default is all IPs)") { |conf.host| }
    opts.on("-p", "--port NUM", "Port for web server (defaults to #{conf.port})") { |conf.port| }
    opts.on("-d", "--database FILE", "Database file (defaults to #{conf.db})") { |conf.db| }
    opts.on("-l", "--log FILE", "Start a database log ('-' for STDOUT)") { |conf.log| }
    opts.on("-C", "--console", "Run in console mode with IRB") { conf.server = :console }
    opts.on("-s", "--server", "Server to force (mongrel, webrick, console)") { |s| conf.server = s.to_sym }

    opts.separator ""
    opts.separator "Common options:"
  
    # No argument, shows at tail.  This will print an options summary.
    # Try it and see!
    opts.on_tail("-?", "--help", "Show this message") do
        puts opts
        exit
    end
  
    # Another typical switch to print the version.
    opts.on_tail("-v", "--version", "Show version") do
        class << Gem; attr_accessor :loaded_specs; end
        puts Gem.loaded_specs['camping'].version
        exit
    end
end

opts.parse! ARGV
if ARGV.length < 1
    puts opts
    exit
end

unless conf.database
    conf.database = {:adapter => 'sqlite3', :database => conf.db}
end
Camping::Models::Base.establish_connection conf.database

if conf.log
    Camping::Models::Base.logger = Logger.new(conf.log == "-" ? STDOUT : conf.log)
end
begin
    Camping::Models::Session.create_schema
rescue MissingSourceFile
    puts "** #$0 stopped: SQLite3 not found, please install."
    puts "** See http://code.whytheluckystiff.net/camping/wiki/BeAlertWhenOnSqlite3 for instructions."
    exit
end

if conf.database[:adapter] == 'sqlite3'
    begin
        require 'sqlite3_api'
    rescue LoadError
        puts "!! Your SQLite3 adapter isn't a compiled extension."
        abort "!! Please check out http://code.whytheluckystiff.net/camping/wiki/BeAlertWhenOnSqlite3 for tips."
    end
end

apps = ARGV.inject([]) do |apps, script|
    if File.directory? script
        apps.push(*Dir[File.join(script, '*.rb')])
    else
        apps << script
    end
end

apps.map! { |script| Camping::Reloader.new(script) }
abort("** No apps successfully loaded") unless apps.detect { |app| app.klass }

def apps.index_page
    welcome = "You are Camping"
    apps = self
    b = Markaby::Builder.new({}, {})
    b = b.instance_eval do
        html do
            head do
                title welcome
                style <<-END, :type => 'text/css'
                    body { 
                        font-family: verdana, arial, sans-serif; 
                        padding: 10px 40px; 
                        margin: 0; 
                    }
                    h1, h2, h3, h4, h5, h6 {
                        font-family: utopia, georgia, serif;
                    }
                END
            end
            body do
                h1 welcome
                p %{Good day.  These are the Camping apps you've mounted.}
                ul do
                    apps.each do |app|
                        next unless app.klass
                        li do
                            h3(:style => "display: inline") { a app.klass.name, :href => "/#{app.mount}" }
                            small { text " / " ; a "View Source", :href => "/code/#{app.mount}" }
                        end
                    end
                end
            end
        end
    end
    b.to_s
end

# Check that mongrel exists 
unless conf.server 
    begin
        require 'mongrel'
        require 'mongrel/camping'
        conf.server = :mongrel
    rescue LoadError 
        conf.server = :webrick 
    end
end

case conf.server 
when :mongrel
    class IndexHandler < Mongrel::HttpHandler
        def initialize(apps)
            @apps = apps
        end
        def process(req, res)
            res.start(200) do |head, out|
                out << @apps.index_page
            end
        end
    end
    class ViewSource < Mongrel::HttpHandler
        def initialize(app)
            @app = app
        end
        def process(req, res)
            res.start(200) do |head, out|
                head['Content-Type'] = 'text/plain'
                out << @app.view_source
            end
        end
    end
    begin
        config = Mongrel::Configurator.new :host => conf.host do
            listener :port => conf.port do
                if apps.length > 1
                    apps.each do |app|
                        uri "/#{app.mount}", :handler => Mongrel::Camping::CampingHandler.new(app)
                        uri "/code/#{app.mount}", :handler => ViewSource.new(app)
                    end
                    uri "/", :handler => IndexHandler.new(apps)
                else
                    uri "/", :handler => Mongrel::Camping::CampingHandler.new(apps.first)
                end
                uri "/favicon.ico", :handler => Mongrel::Error404Handler.new("")
                trap("INT") { stop }
                run
            end
        end 

        puts "** Camping running on #{conf.host}:#{conf.port}."
        config.join
    rescue Errno::EADDRINUSE
        puts "** ERROR : address #{conf.host}:#{conf.port} already in use."
    end
when :webrick
    require 'webrick/httpserver'
    require 'camping/webrick'

    # Mount the root
    s = WEBrick::HTTPServer.new(:BindAddress => conf.host, :Port => conf.port)
    if apps.length > 1
        apps.each do |app|
            s.mount "/#{app.mount}", WEBrick::CampingHandler, app
            s.mount_proc("/code/#{app.mount}") do |req, resp|
                resp['Content-Type'] = 'text/plain'
                resp.body = app.view_source
            end
        end
        s.mount_proc("/") { |req, resp| resp.body = apps.index_page }
    else
        s.mount "/", WEBrick::CampingHandler, apps.first
    end

    # Server up
    trap(:INT) do
        s.shutdown
    end
    s.start
when :console 
    ARGV.clear # Avoid passing args to IRB 

    require 'irb' 
    require 'irb/completion' 
    IRB.start 
end
